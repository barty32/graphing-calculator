
// GRAPH.TS -------------------------------------------------------------------------------------------

// for (let i = -this.xOffset; i < this.width - this.xOffset; i++){
//     if (i % 100 == 0) {
//         this.ctx.beginPath();
//         this.ctx.rect((i + this.xOffset) * this.xScale, 0, 2, this.height);
//         this.ctx.fill();
//     }
// }
// for (let i = -this.yOffset; i < this.width - this.yOffset; i++) {
//     if (i % 100 == 0) {
//         this.ctx.beginPath();
//         this.ctx.rect(0, (i + this.yOffset) * this.yScale, this.width, 2);
//         this.ctx.fill();
//     }
// }
//
//
// for (let i = 0; i < this.width; i += gridScale.x) {
//     this.ctx.beginPath();
//     this.ctx.rect(i, 0, 2, this.height);
//     this.ctx.fill();
// }

// private zoomTouch(distance: number, x: number, y: number) {
//     const newScale = this.xScale * (distance / this.lastDistance);
//     this.yScale = this.xScale = this.xScale * (distance / this.lastDistance);

//     this.xOffset = -(x - (x + this.xOffset) * (distance / this.lastDistance));
//     this.yOffset = y - (y - this.yOffset) * (distance / this.lastDistance);

//     this.draw();
// }

// const scale = 1 / this.xScale;
// const gridScale = 2 ** (Math.log2(128 * scale) | 0);
// const size = Math.max(this.width, this.height) * scale + gridScale * 2;
// const x = ((this.xOffset * scale - gridScale) / gridScale | 0) * gridScale;
// const y = ((this.yOffset * scale - gridScale) / gridScale | 0) * gridScale;
// this.ctx.lineWidth = 1;
// this.ctx.strokeStyle = "grey";
// this.ctx.beginPath();
// for (let i = 0; i < size; i += gridScale) {
//     this.ctx.moveTo(x + i, y);
//     this.ctx.lineTo(x + i, y + size);
//     this.ctx.moveTo(x, y + i);
//     this.ctx.lineTo(x + size, y + i);
// }
// this.ctx.setTransform(1, 0, 0, 1, 0, 0); // reset the transform so the lineWidth is 1
// this.ctx.stroke();
// for (let i = 0; i < this.width; i++){
//     if (Math.abs(((i + this.xOffset) / this.xScale) % xGrid) < 1 / this.xScale) {
//         //draw subgrid
//         for (let j = 0; j < xGrid; j += xGrid / 5){
//             this.ctx.beginPath();
//             this.ctx.rect(i + j, 0, 0.5, this.height);
//             this.ctx.fill();
//         }


//         this.ctx.beginPath();
//         this.ctx.rect(i , 0, 2, this.height);
//         this.ctx.fill();
//     }
// }
// for (let i = 0; i < this.height; i++) {
//     if (Math.abs(((-i + this.yOffset) / this.yScale) % yGrid) < 1 / this.yScale) {
//         this.ctx.beginPath();
//         this.ctx.rect(0, i, this.width, 2);
//         this.ctx.fill();
//     }
// }

//let prevTouch: Touch | null = null;
        //touch handlers
        // this.canvas.ontouchstart = (e) => {
        //     this.moving = true;
        // }
        // this.canvas.ontouchmove = (e) => {
        //     const touch = e.touches[0];
        //     if (this.moving && prevTouch) {
        //         this.move(touch.pageX - prevTouch.pageX, touch.pageY - prevTouch.pageY);
        //     }
        //     prevTouch = touch;
        // }
        // this.canvas.ontouchend = (e) => {
        //     this.moving = false;
        //     prevTouch = null;
        // }

            // private prettyPrintExponent(expr: string) {
    //     //expr must be valid exponent format string, i.e.:'5e+23' or '6e-8'
    //     const num = Number(expr);
    //     if (isNaN(num) || !isFinite(num)) {
    //         return expr;
    //     }
    //     if (num == 0) {
    //         return '0';
    //     }
    //     const expPos = expr.indexOf('e');
    //     const exponent = expr.substring(expr.charAt(expPos + 1) == '+' ? expPos + 2 : expPos + 1);
    //     return `${expr.substring(0, expPos)}·10<sup>${exponent}</sup>`;
    // }

    //const sp = str.split('.')
        //return sp[0] + (sp[1] ? '.' + (sp[1][0] ? sp[1][0] : '') + (sp[1][1] ? sp[1][1] : '') : '');//(Math.round(value / round) * round).toPrecision(1);


// addLine(fn: GraphFn, name: string, xRes = Infinity, color: string) {
//     this.lines.push({ fn, color, id: lineID, name, on: true, xRes });
// }

// removeLine(id: number) {
//     this.lines.find((line: Line, index: number) => {
//         if (line.id == id) {
//             this.lines.splice(index, 1);
//             return true;
//         }
//         return false;
//     });
// }

// getLine(id: number): LineParams {
//     const line = this.lines.find((line) => {
//         if (line.id == id) return true;
//     });
//     if (!line) throw new Error('Line with this ID does not exist');
//     return line;
// }



// private getGridOffsets(tileWidth: number, tileHeight: number) {//xGrid: number, yGrid: number
//     let x = 0;
//     let y = 0;
//     for (let i = 0; i < this.width; i++){
//         if (Math.abs(((i + this.xOffset) / this.xScale) % xGrid) <= 1 / this.xScale) {
//             x = i - xGrid * this.xScale;
//             break;
//         }
//     }
//     for (let i = 0; i < this.height; i++) {
//         if (Math.abs(((-i + this.yOffset) / this.yScale) % yGrid) <= 1 / this.yScale) {
//             y = i - yGrid * this.yScale;
//             break;
//         }
//     }
//     return { x: x, y: y };
// }


//['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹'];


// function roundTo(value: number, round: number) {
//     return value - value % round;
// }


//working draw:
// draw() {
//     const oldFill = this.ctx.fillStyle;
//     this.ctx.fillStyle = this.options.background;
//     this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
//     if (this.options.grid)
//         this.drawGrid();
//     for (const lineKey in this.lines) {
//         const line = this.lines[lineKey];
//         if (!line || !line.on) continue;
//         this.ctx.beginPath();
//         this.ctx.strokeStyle = line.color;
//         this.ctx.lineWidth = this.options.lineWidth;
//         //move to initial position
//         this.ctx.moveTo(0, line.fn(this.xOffset / this.xScale) * -this.yScale + this.yOffset);

//         let yPrev = line.fn(this.xOffset / this.xScale) * -this.yScale + this.yOffset;

//         if (!line.xRes) {//infinite resolution
//             for (let i = 0; i < this.width; i++) {//let i = -this.xOffset; i < this.width - this.xOffset; i += 1/*1 / this.xScale*/
//                 //this.ctx.lineTo(i + this.xOffset, fn(i / 31.8 / (this.width - 2 * this.xOffset)) * -200 + this.yOffset);
//                 const x = (i + this.xOffset) / this.xScale;

//                 let y;// = line.cache[x];
//                 //if (y === undefined) {
//                 const res = line.fn(x)
//                 y = res * -this.yScale + this.yOffset;
//                 //line.cache[x] = res;
//                 //}
//                 //else {
//                 //    y = y * -this.yScale + this.yOffset;
//                 //}
//                 const delta = Math.abs(y - yPrev);
//                 if ((yPrev < 0 || yPrev > this.height) && (y < 0 || y > this.height)) {
//                     continue;
//                 }
//                 else if ((yPrev < 0 || yPrev > this.height) && (y >= 0 && y <= this.height)) {
//                     this.ctx.moveTo(i, yPrev);
//                     //this.ctx.arc(i, yPrev, 1, 0, 2 * Math.PI);
//                     this.ctx.lineTo(i, yPrev);
//                 }
//                 // if (y < 0 || y > this.height) {
//                 //     for (let j = i - 1; j < i; j += 1 / delta * 8) {
//                 //         let xNew = (j + this.xOffset) / this.xScale;
//                 //         let yNew = line.fn(xNew) * -this.yScale + this.yOffset;
//                 //         if (yNew < 0) yNew = 0;
//                 //         if (yNew > this.height) yNew = this.height;
//                 //         this.ctx.moveTo(j, yNew);
//                 //         this.ctx.arc(j, yNew, 1, 0, 2 * Math.PI);
//                 //     }
//                 // }

//                 // TODO: add discontinuity detection
//                 // if (y > 10 * this.height || y < -(10 * this.height)) {
//                 //     this.ctx.moveTo(i, y);
//                 //     continue;
//                 // }
//                 yPrev = y;
//                 //this.ctx.moveTo(i, y);
//                 //this.ctx.arc(i, y, 1, 0, 2 * Math.PI);
//                 this.ctx.lineTo(i, y);
//             }
//         } else {
//             for (let i = -line.xRes * this.xScale; i < this.width + line.xRes * this.xScale; i++) {
//                 const x = (i + this.xOffset) / this.xScale;
//                 if (line.xRes && Math.abs(x % line.xRes) > 1 / this.xScale) continue;
//                 const y = line.fn(x / (line.xRes ? line.xRes : 1)) * -this.yScale + this.yOffset;
//                 this.ctx.lineTo(i, y);
//             }
//         }
//         this.ctx.stroke();
//         console.log(Object.keys(line.cache).length);
//     }
//     this.ctx.fillStyle = oldFill;
// }


// AUDIO.TS -------------------------------------------------------------------------------------------

//gainNode1: GainNode;
//gainNode2: GainNode;
//audioBuffer1: AudioBuffer;
//audioBuffer2: AudioBuffer;
//bufferNode1: AudioBufferSourceNode | null = null;
//bufferNode2: AudioBufferSourceNode | null = null;
//scriptNode: ScriptProcessorNode;

//constructor()
//this.gainNode1 = this.audioCtx.createGain();
//this.gainNode2 = this.audioCtx.createGain();
//this.gainNode1.connect(this.audioCtx.destination);
//this.gainNode2.connect(this.audioCtx.destination);
//this.audioBuffer1 = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate, this.audioCtx.sampleRate);
//this.audioBuffer2 = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate, this.audioCtx.sampleRate);

//addNode()
    //const node = this.nodes[id] = {
//    playing: false,
//    fn,
    //oscNode: this.audioCtx.createOscillator(),
    //gainNode: this.audioCtx.createGain(),
    //audioBuffer: this.audioCtx.createBuffer(1, this.audioCtx.sampleRate, this.audioCtx.sampleRate),
    //bufferNode: null
//};
//this.gainNode1.gain.linearRampToValueAtTime(0.0001, this.audioCtx.currentTime+0.001);

//await new Promise(r => setTimeout(r, 1));

//this.gainNode1.gain.exponentialRampToValueAtTime(1.0, this.audioCtx.currentTime + 0.002);
//this.playingNodes++;
//this.audioCtx.resume();

//getNode(id: number): AudioNode {
//    const line = this.nodes[id];
//    if (!line) throw new Error('Node with this ID does not exist');
//    return line;
//}

/*stop(stopTime = 0.1) {
    stopTime += this.audioCtx.currentTime;
    this.gainNode.gain.exponentialRampToValueAtTime(0.01, stopTime);
    //this.gainNode.gain.setValueAtTime(0.01, stopTime);
    //for (const nodeKey in this.nodes) {
    //    this.nodes[nodeKey]?.bufferNode?.stop(stopTime);
    //}
    this.bufferNode?.stop(stopTime);
}*/

//stopNode(id: number) {
//    this.nodes[id]?.bufferNode?.stop();
//}
//usingBuffer1 = true;
//started = false;

/*
async start(startTime = 0.001) {
    //startTime += this.audioCtx.currentTime;

    //this.workletNode.port.postMessage({
    //    message: '10 messages received!',
    //    spec: this.nodes[0],
    //});

    const currentBuffer = this.audioBuffer1//this.usingBuffer1 ? this.audioBuffer1 : this.audioBuffer2;
    const currentGain = this.gainNode1//this.usingBuffer1 ? this.gainNode1 : this.gainNode2;
    //const oldGain = this.usingBuffer1 ? this.gainNode2 : this.gainNode1;
    //this.usingBuffer1 = !this.usingBuffer1;

    let rawArray = currentBuffer.getChannelData(0);
    //for (let i = 0; i < currentBuffer.length; i++) {
    //   rawArray[i] = 0;
    //}
    this.playingNodes = 0;

    for (const nodeKey in this.nodes) {
        const node = this.nodes[nodeKey];
        if (!node || !node.playing) continue;
        this.playingNodes++;
        //node.bufferNode = new AudioBufferSourceNode(this.audioCtx, { buffer: node.audioBuffer, loop: true });
        //node.bufferNode.connect(this.gainNode);
        
        //for (let i = 0; i < currentBuffer.length; i++) {
        //    rawArray[i] += node.fn(i * 1000 / this.audioCtx.sampleRate);//Math.sin(i * 2 * Math.PI / this.audioCtx.sampleRate * 1000);
        //}
    }

    for (let i = 0; i < currentBuffer.length; i++) {
        rawArray[i] = 0;

        for (const nodeKey in this.nodes) {
            const node = this.nodes[nodeKey];
            if (!node || !node.playing) continue;
            //this.playingNodes++;

            rawArray[i] += node.fn(i * 1000 / this.audioCtx.sampleRate) ?? 0;//Math.sin(i * 2 * Math.PI / this.audioCtx.sampleRate * 1000);
        }
    }

    //this.stop(0);
    //this.bufferNode?.disconnect();

    if (this.playingNodes === 0) {
        this.bufferNode2?.stop();
        this.bufferNode2?.disconnect();
        this.started = false;
        return;
    };

    if (!this.started) {
        this.started = true;
        //if (!this.bufferNode) {
        this.bufferNode1 = new AudioBufferSourceNode(this.audioCtx, { buffer: currentBuffer, loop: true });
        //this.bufferNode.connect(this.gainNode);
        //this.bufferNode.start();
        //}
        //return;
        //this.bufferNode.buffer = this.audioBuffer;
        this.bufferNode1.connect(currentGain);

        //because FF
        //currentGain.gain.setValueAtTime(0.0001, this.audioCtx.currentTime);
        //currentGain.gain.exponentialRampToValueAtTime(1.0, this.audioCtx.currentTime + 0.1);
        this.bufferNode1.start();
    }

    //const stopTime = this.audioCtx.currentTime + 0.1;

    //oldGain.gain.exponentialRampToValueAtTime(0.0001, stopTime);

    //this.bufferNode2?.stop(stopTime);
    //this.bufferNode2?.disconnect();
    //this.bufferNode2 = this.bufferNode1;
}
*/



    // start(startTime = 0.1) {
    //     startTime += this.audioCtx.currentTime;
    //     //this.gainNode.gain.value = 1;
    //     //because FF
    //     this.gainNode.gain.setValueAtTime(1.0, startTime);
    //     //for (const nodeKey in this.nodes) {
    //     //    this.nodes[nodeKey]?.bufferNode?.start(startTime);
    //     //}
    //     this.bufferNode?.start();
    // }

    //init() {
        // this.audio = {
        //     //custom: false,
        //     waveType: 'sine',
        //     frequency: 440,
        //     amplitude: 50,
        //     duty: 50,
        //     skew: 50,
        //     phase: 0,
        //     bias: 0,
        // };
        //this.audioCtx = new AudioContext();
        //this.oscNode = this.audioCtx.createOscillator();
        //this.gainNode = this.audioCtx.createGain();
        //this.bufferNode = this.audioCtx.createBufferSource();
        //this.audioBuffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate, this.audioCtx.sampleRate);
        //this.gainNode.gain.value = 0.5;
        //this.oscNode.connect(this.gainNode);
        //this.bufferNode.connect(this.gainNode);
        //this.gainNode.connect(this.audioCtx.destination);
    //}


    // generateAudio() {
    //     if (!this.audioCtx || !this.audioBuffer) {
    //         console.warn('Audio context or audio buffer is null');
    //         return;
    //     }
    //     const line = graph.getLine(this.id);

    //     let nowBuffering = this.audioBuffer.getChannelData(0);
    //     for (var i = 0; i < this.audioBuffer.length; i++) {
    //         nowBuffering[i] = line.fn(i * 1000 / this.audioCtx.sampleRate);//Math.sin(i * 2 * Math.PI / this.audioCtx.sampleRate * 1000);
    //     }
    //     const oldBuffer = this.bufferNode;
    //     this.bufferNode = new AudioBufferSourceNode(this.audioCtx);
    //     this.bufferNode.buffer = this.audioBuffer;
    //     this.bufferNode.connect(this.audioCtx.destination);
    //     this.bufferNode.loop = true;
    //     if (this.playing) {
    //         this.bufferNode.start();
    //         oldBuffer?.stop();
    //     }
    // }


/*start(startTime = 0.001) {
    startTime += this.audioCtx.currentTime;

    const currentBuffer = this.usingBuffer1 ? this.audioBuffer1 : this.audioBuffer2;
    const currentGain = this.usingBuffer1 ? this.gainNode1 : this.gainNode2;
    const oldGain = this.usingBuffer1 ? this.gainNode2 : this.gainNode1;
    this.usingBuffer1 = !this.usingBuffer1;

    let rawArray = currentBuffer.getChannelData(0);
    for (let i = 0; i < currentBuffer.length; i++) {
        rawArray[i] = 0;
    }
    this.playingNodes = 0;

    for (const nodeKey in this.nodes) {
        const node = this.nodes[nodeKey];
        if (!node || !node.playing) continue;
        this.playingNodes++;
        //node.bufferNode = new AudioBufferSourceNode(this.audioCtx, { buffer: node.audioBuffer, loop: true });
        //node.bufferNode.connect(this.gainNode);
        
        for (let i = 0; i < currentBuffer.length; i++) {
            rawArray[i] += node.fn(i * 1000 / this.audioCtx.sampleRate);//Math.sin(i * 2 * Math.PI / this.audioCtx.sampleRate * 1000);
        }
    }

    //this.stop(0);
    //this.bufferNode?.disconnect();

    if (this.playingNodes === 0) {
        this.bufferNode2?.stop();
        this.bufferNode2?.disconnect();
        return;
    };

    //if (!this.bufferNode) {
        this.bufferNode1 = new AudioBufferSourceNode(this.audioCtx, { buffer: currentBuffer, loop: true });
        //this.bufferNode.connect(this.gainNode);
        //this.bufferNode.start();
    //}
    //return;
    //this.bufferNode.buffer = this.audioBuffer;
    this.bufferNode1.connect(currentGain);

    
    //this.gainNode.gain.value = 1;
    //because FF
    currentGain.gain.setValueAtTime(0.0001, this.audioCtx.currentTime);
    currentGain.gain.exponentialRampToValueAtTime(1.0, this.audioCtx.currentTime + 0.1);
    //for (const nodeKey in this.nodes) {
    //    this.nodes[nodeKey]?.bufferNode?.start(startTime);
    //}
    this.bufferNode1.start();

    const stopTime = this.audioCtx.currentTime + 0.1;

    oldGain.gain.exponentialRampToValueAtTime(0.0001, stopTime);

    this.bufferNode2?.stop(stopTime);
    //this.bufferNode2?.disconnect();
    this.bufferNode2 = this.bufferNode1;
}*/


// CALCULATOR.TS -------------------------------------------------------------------------------------------

// fileInput.files[0].text().then((jsonData) => {
//     const obj = JSON.parse(jsonData);
//     if (obj.format != "GraphingCore_v1.0") throw new Error("Unsupported JSON file format");
//     this.data = obj.data;
//     graph.getLine(this.id).xRes = obj.resolution;
//     graph.attachFn(this.id, (x) => {
//         return this.data[Math.round(x)];
//     });
//     graph.draw();
// })

// function getLine(id: string) {
//     const line = lines.find((line) => {
//         if (line.id == id) return true;
//     });
//     if (!line) throw new Error('Line with this ID does not exist');
//     return line;
// }


// function playAudio(pfn: (x: number) => number) {
//     const audioCtx = new AudioContext();//|| window.webkitAudioContext
//     //console.log(audioCtx.sampleRate);
//     const myArrayBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);

//     let nowBuffering = myArrayBuffer.getChannelData(0);
//     for (var i = 0; i < myArrayBuffer.length; i++) {
//         nowBuffering[i] = pfn(i / audioCtx.sampleRate);//Math.sin(i * 2 * Math.PI / audioCtx.sampleRate * 1000);//Math.random() * 2 - 1;
//     }

//     //currentLine.playing = true;

//     const source = audioCtx.createOscillator();

//     // const source = audioCtx.createBufferSource();
//     // source.buffer = myArrayBuffer;
//     source.connect(audioCtx.destination);
//     // source.loop = true;
//     //source.start()
//     return source;
// }

//play audio
// if (audioMgr.getNode(this.id).playing) {
//     audioMgr.getNode(this.id).playing = false;
//     //this.audioCtx?.suspend();
//     btn2.innerHTML = play;//'<img src="/assets/images/play.svg">';
//     audioMgr.start();
//     //console.log('Audio stopped');
// }
// else {
//     btn2.innerHTML = pause;//'<img src="/assets/images/pause.svg">';
//     //this.generateAudio();
//     //if (!oscStarted) {
//     //this.oscNode?.start();
//     //this.bufferNode?.start();
//     //oscStarted = true;
//     //}
//     audioMgr.getNode(this.id).playing = true;
//     //mgr.prepareAllNodes();
//     audioMgr.start();
//     //this.audioCtx?.resume();
//     //console.log('Audio started');
// }


// function test() {

//     const fn = (x: number) => {
//         //return Math.sin(x);
//         return (Math.abs(parseInt((x).toFixed(0)))) % 2 - 1 / 2;
//         //return 0.5 * (Math.sin(200 * x) + Math.sin(400 * x) + Math.sin(800 * x));
//         //return 100 * Math.cos(x * 2 * Math.PI);
//     }
//     const fn2 = (x: number) => {
//         return 1 / x;
//     }
//     const fn3 = (x: number) => {
//         return Math.sin(x);
//     }
//     graph.addLine(fn, "red");
//     graph.addLine(fn2, "#2222FF");
//     graph.addLine(fn3, "#00FF00");
//     graph.draw();
//     //play(fn);
// }

//lines.push(new Line(LineType.expression));
//lines.push(new Line(LineType.audio));
//lines.push(new Line(LineType.rawData));

    // waveList.innerHTML = waveList.innerHTML + `
    //     <div class="sub-container rounded wave-box" id="${id}">
    //         <div class="input-group">
    //             <a type="button" class="btn btn-secondary wave-btn">
    //                 <img src="/assets/images/about.svg">
    //             </a>
    //             <input type="text" class="form-control" value="${id}">
    //             <a type="button" class="btn btn-success wave-btn">
    //                 <img src="/assets/images/play.svg">
    //             </a>
    //             <a type="button" class="btn btn-secondary wave-btn">
    //                 <img src="/assets/images/settings.svg">
    //             </a>
    //             <a type="button" class="btn btn-danger wave-btn">
    //                 <img src="/assets/images/trash.svg">
    //             </a>
    //         </div>
    //         <div class="input-group mt-2">
    //             <span class="input-group-text input-label-box">f(x):</span>
    //             <input type="text" class="form-control">
    //         </div>
    //     </div>
    // `;


// getUniqueId() {
//     let i = lines.length;
//     let id: string;
//     do {
//         if (this.type == LineType.audio) {
//             id = 'audioLine' + i;
//         }
//         else if (this.type == LineType.rawData) {
//             id = 'dataLine' + i;
//         }
//         else {
//             id = 'line' + i;
//         }
//         i++;
//     }
//     while (lines.find((line) => {
//         if (line.id == id) return true;
//     }));
//     return id;
// }

    // initAudioSystem() {
    //     this.audio = {
    //         //custom: false,
    //         waveType: 'sine',
    //         frequency: 440,
    //         amplitude: 50,
    //         duty: 50,
    //         skew: 50,
    //         phase: 0,
    //         bias: 0,
    //     };
    //     this.audioCtx = new AudioContext();
    //     this.oscNode = this.audioCtx.createOscillator();
    //     this.gainNode = this.audioCtx.createGain();
    //     //this.bufferNode = this.audioCtx.createBufferSource();
    //     this.audioBuffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate, this.audioCtx.sampleRate);
    //     this.gainNode.gain.value = 0.5;
    //     //this.oscNode.connect(this.gainNode);
    //     //this.bufferNode.connect(this.gainNode);
    //     this.gainNode.connect(this.audioCtx.destination);
    // }

    // generateAudio() {
    //     if (!this.audioCtx || !this.audioBuffer) {
    //         console.warn('Audio context or audio buffer is null');
    //         return;
    //     }
    //     const line = graph.getLine(this.id);

    //     let nowBuffering = this.audioBuffer.getChannelData(0);
    //     for (var i = 0; i < this.audioBuffer.length; i++) {
    //         nowBuffering[i] = line.fn(i * 1000 / this.audioCtx.sampleRate);//Math.sin(i * 2 * Math.PI / this.audioCtx.sampleRate * 1000);
    //     }
    //     const oldBuffer = this.bufferNode;
    //     this.bufferNode = new AudioBufferSourceNode(this.audioCtx);
    //     this.bufferNode.buffer = this.audioBuffer;
    //     this.bufferNode.connect(this.audioCtx.destination);
    //     this.bufferNode.loop = true;
    //     if (this.playing) {
    //         this.bufferNode.start();
    //         oldBuffer?.stop();
    //     }
    // }


    //bind this in functions
        //this.getUniqueId        = this.getUniqueId.bind(this);
        //this.initAudioSystem    = this.initAudioSystem.bind(this);
        //this.generateAudio      = this.generateAudio.bind(this);
        //this.onChangeVisibility = this.onChangeVisibility.bind(this);
        //this.createWaveBox      = this.createWaveBox.bind(this);

// lines.find((value, index) => {
    //     if (value.id == this.id) {
    //         lines.splice(index, 1);
    //         graph.removeLine(this.id);
    //         graph.draw();
    //         return true;
    //     }
    //     return false;
    // });

    //triangle wave
    //return line.audio.amplitude / 100 * Math.min((((line.audio.frequency * x * 2 / 1000 - line.audio.phase / 360*2) % 2) + 2) % 2, Math.abs(((-(line.audio.frequency * x * 2 / 1000 - line.audio.phase / 360*2) % 2) + 2) % 2)) - 1;


            //play audio
        // if (audioMgr.getNode(this.id).playing) {
        //     audioMgr.getNode(this.id).playing = false;
        //     if (boxBtn) boxBtn.innerHTML = play;
        //     if (topBtn) topBtn.innerHTML = play;
        //     audioMgr.start();
        // }
        // else {
        //     if (boxBtn) boxBtn.innerHTML = pause;
        //     if (topBtn) topBtn.innerHTML = pause;
        //     audioMgr.getNode(this.id).playing = true;
        //     audioMgr.start();
        // }



//math input

const row2 = document.createElement('div');
        row2.classList.add('input-group', 'mt-2');
        row2.innerHTML = `<span class="input-group-text input-label-box">f(x):</span>`;
        const errorImg = document.createElement('img');
        errorImg.src = '/assets/images/error.svg';
        errorImg.classList.add('error-img');
        row2.appendChild(errorImg);
        const tooltip = document.createElement('span');
        tooltip.classList.add('e-tooltip', 'rounded');
        row2.appendChild(tooltip);
        const fnInput = document.createElement('input');
        fnInput.type = 'text';
        fnInput.id = `expr-input-${this.id}`;
        fnInput.classList.add('form-control');
        fnInput.addEventListener('input', (e) => {

            this.expression = fnInput.value;
            try {
                this.parser.tokenize(this.expression).parse();
                console.log(this.parser.tokenStack);
                console.log(this.parser.outputQueue);
                this.parser.evaluate({ x: Infinity, degrees: degrees ? 1 : 0 });
                errorImg.style.display = 'none';
            }
            catch (e) {
                errorImg.style.display = 'block';
                const tText = row2.querySelector('.e-tooltip');
                if (tText) tText.innerHTML = (e as Error).message;
                return;
            }

            //TODO: use better math parser
            // try {
            //     graph.getLine(id).fn = new Function('x', `return ${(e.target as HTMLInputElement).value}`)
            // }
            // catch (e) {
            //     errorImg.style.display = 'block';
            //     const tText = row2.querySelector('.e-tooltip');
            //     if (tText) tText.innerHTML = e.message;
            // }
            //     (x) => {
            //     return eval((e.target as HTMLInputElement).value);
            // }

            //square
            //sin(x)+1/3sin(3x)+1/5sin(5x)+1/7sin(7x)+1/9sin(9x)+1/11sin(11x)+1/13sin(13x)+1/15sin(15x)+1/17sin(17x)+1/19sin(19x)+1/21sin(21x)

            graph.attachFn(this.id, (x) => {
                // let result = Infinity;
                // try {
                //     result = Parser.evaluate({ x: x });
                //     errorImg.style.display = 'none';
                // }
                // catch (e) {
                //     errorImg.style.display = 'block';
                //     const tText = row2.querySelector('.e-tooltip');
                //     if (tText) tText.innerHTML = (e as Error).message;
                // }
                // return result;
                return this.parser.evaluate({ x: x, degrees: degrees ? 1 : 0 });
                //if (this.parser.result === null) {
                //    return undefined;
                //}
                //return this.parser.result;
            });
            graph.draw();

            // graph.getLine(this.id).fn = (x) => {
            //     let result = Infinity;
            //     try {
            //         result = Parser.evaluate(this.expression, { x: x }, { useRadians: true });
            //         errorImg.style.display = 'none';
            //     }
            //     catch (e) {
            //         errorImg.style.display = 'block';
            //         const tText = row2.querySelector('.e-tooltip');
            //         if (tText) tText.innerHTML = (e as Error).message;
            //     }
            //     return result;
            // }
            // graph.draw();



            if (this.type == LineType.audio && this.audioData?.waveType == 'custom') {
                this.audioDataChanged();
            }
        });
        if (this.type == LineType.audio) {
            fnInput.disabled = true;
            currentEditedLine = this;
            this.audioDataChanged();
        }
        row2.appendChild(fnInput);
        parent.appendChild(row2);



// INDEX.PHP ----------------------------------------------------------------------------------------

<!-- <script type="module">
            import Graph from './graph.js';

            const graph = new Graph(document.querySelector('#graph'));

            console.log('adding line:' + graph.addLine(() => {
                return Infinity
            }, 'name', 0, 'lime'));
            console.log('adding line:' + graph.addLine(() => {
                return Infinity
            }, 'name', 0, 'red'));
            console.log('adding line:' + graph.addLine(() => {
                return Infinity
            }, 'name', 0, 'blue'));

            graph.removeLine(1)

            console.log(graph.getLine(2));

            graph.draw();
        </script> -->



// PARSER.TS ------------------------------------------------------------------------------------------
function isNumber(char: string) { 
    return /\d|\./.test(char);
}

function isLetter(char: string) {
    if (!char) return false;
    return /[a-z]/i.test(char);
}

function isLParen(char: string) {
    return /\(|\[|\{/.test(char);
}

function isRParen(char: string) {
    return /\)|\]|\}/.test(char);
}

function isQuote(char: string) {
    return /\'|\"|\`/.test(char);
}

function isEqual(char: string) {
    return /\=|\<|\>/.test(char);
}

function isOperator(str: string) {
    return operators[str] !== undefined;
}

function isConstant(char: string) {
    return constants[char] !== undefined;
}

//tokenize
for (let i = 0; i < expression.length; i++) {
            let char = expression[i];
            let nextChar = expression[i + 1];

            if (char === ' ') {
                continue;
            }
            else if (isNumber(char)) {
                const pos = i;
                let charStack = char;
                while (isNumber(nextChar)){
                    charStack += nextChar;
                    char = expression[++i];
                    nextChar = expression[i + 1];
                }
                
                this.tokenStack.push({ type: TokenType.NUMBER, value: parseFloat(charStack), pos });
            }
            else if (isLetter(char)) {
                let pos = i;
                let charStack = char;
                while (isLetter(nextChar)) {
                    charStack += nextChar;
                    char = expression[++i];
                    nextChar = expression[i + 1];
                }

                charstackLoop: while(charStack.length){
                    //functions has to be sorted from longest to shortest
                    for (const fn in functions) {
                        if (charStack.search(new RegExp(`^${fn}`)) !== -1) {
                            //found function
                            charStack = charStack.substring(fn.length);
                            this.tokenStack.push({ type: TokenType.FUNCTION, name: fn, pos });
                            pos += fn.length;
                            continue charstackLoop;
                        }
                    }
                    //it can be 'e' constant
                    if (isConstant(charStack[0])) {
                        this.tokenStack.push({ type: TokenType.NUMBER, value: constants[charStack[0]], pos });
                    }
                    else {
                        this.tokenStack.push({ type: TokenType.VARIABLE, name: charStack[0], pos });
                    }
                    //pop from front
                    charStack = charStack.substring(1);
                    pos++;
                }
            }
            else if (isConstant(char)) {
                this.tokenStack.push({ type: TokenType.NUMBER, value: constants[char], pos: i });
            }
            else if (isOperator(char)) {
                if (nextChar == '*' || nextChar == '<' || nextChar == '>') {
                    char += nextChar;
                    i++;
                }
                if (char == '!') {
                    let newPos = -1;
                    switch (this.tokenStack.at(-1)?.type) {
                        case TokenType.NUMBER:
                        case TokenType.VARIABLE:
                            newPos = this.tokenStack.length - 1;
                            break;
                        case TokenType.RPAREN:
                            for (let j = this.tokenStack.length - 1; j >= 0; j--) {
                                if (this.tokenStack[j].type == TokenType.LPAREN) {
                                    newPos = j;
                                    break;
                                }
                            }
                            //throw mismatched parentheses
                            break;
                        default:
                            //throw invalid position
                    }
                    this.tokenStack.splice(newPos, 0, { type: TokenType.OPERATOR, name: char, precedence: operators[char].precedence, associativity: operators[char].assoc, pos: i });
                    continue;
                }
                this.tokenStack.push({ type: TokenType.OPERATOR, name: char, precedence: operators[char].precedence, associativity: operators[char].assoc, pos: i });
            }
            else if (isLParen(char)) {
                this.tokenStack.push({ type: TokenType.LPAREN, pos: i });
            }
            else if (isRParen(char)) {
                this.tokenStack.push({ type: TokenType.RPAREN, pos: i });
            }
            else if (char == ',') {
                this.tokenStack.push({ type: TokenType.COMMA, pos: i });
            }
            else if (isEqual(char)) {
                this.tokenStack.push({ type: TokenType.EQUAL, pos: i });    
            }
            // else if (isQuote(char)) {
            //     charStack += char;
            //     if (isLetter(nextChar)) {
            //         continue;
            //     }

            //     this.tokenStack.push({ type: TokenType.STRING, value: char, precedence: 0, associativity: 'none', pos: i, arguments: 0 });
            // }
            else {
                this.problems.push(problem(i, 1, Severity.ERROR, `Invalid token '${char}'`));
            }
        }
        return this;

//working parse function
parse(tokens: Token[] = this.tokenStack, destination: Token[] = this.outputQueue) {
        const operatorStack: Token[] = [];
        tokenLoop: for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const nextToken: Token | undefined = tokens[i + 1];

            if (token.type == TokenType.VARIABLE) {
                if (nextToken?.type == TokenType.NUMBER ||
                    nextToken?.type == TokenType.FUNCTION ||
                    nextToken?.type == TokenType.VARIABLE ||
                    nextToken?.type == TokenType.LPAREN) {
                    tokens.splice(i + 1, 0, insertMultiplyToken(token.pos));
                }
                destination.push(token);
            }
            else if (token.type == TokenType.FUNCTION) {
                if (nextToken?.type == TokenType.OPERATOR) {
                    //tokens.splice(i+1, 0, createMultiplyToken());
                }
                else if (!nextToken) {
                    this.problems.push(problem(token.pos, token.name?.length ?? 0, Severity.WARNING, `Expected function argument, ignoring function '${token.name}'`));
                    continue;
                }
                else if (nextToken.type == TokenType.NUMBER ||
                    nextToken.type == TokenType.FUNCTION ||
                    nextToken.type == TokenType.VARIABLE) {
                    if (functions[token.name ?? ''].argc > 1) {
                        this.problems.push(problem(token.pos, token.name?.length ?? 0, Severity.ERROR, `Functions with more than 1 argument require parentheses`));
                    }
                    //parentheses are missing, so insert them
                    tokens.splice(i + 1, 0, { type: TokenType.LPAREN, pos: i + 1 });

                    for (let j = i + 1; j < tokens.length; j++){
                        if (!(tokens[j].type == TokenType.NUMBER ||
                            tokens[j].type == TokenType.FUNCTION ||
                            tokens[j].type == TokenType.VARIABLE ||
                            (tokens[j].type == TokenType.OPERATOR &&
                            (operators[tokens[j].name ?? ''].precedence > operators['+'].precedence))))
                        {
                            if (tokens[j].type == TokenType.OPERATOR) {
                                tokens.splice(j, 0, { type: TokenType.RPAREN, pos: j });
                                //decrease index and repeat
                                i--;
                                continue tokenLoop;
                            }
                            else {
                                //throw 'add parentheses'
                            }
                        }
                    }
                    tokens.push({ type: TokenType.RPAREN, pos: tokens.length - 1 });
                }
                else if (nextToken?.type == TokenType.LPAREN){
                    //valid, do nothing
                }
                else {
                    this.problems.push(problem(nextToken.pos, 1, Severity.ERROR, `Invalid token '${nextToken.name}', expected '(', function name, variable or number.`));
                }


                let scope = 0;
                let args: Token[][] = [];
                let currentStart = i + 2;
                for (let j = currentStart; j < tokens.length; j++){
                    if (tokens[j].type == TokenType.LPAREN) {
                        scope++;
                        continue;
                    }
                    else if (tokens[j].type == TokenType.RPAREN) {
                        if (scope !== 0) {
                            scope--;
                            continue;
                        }
                        else {
                            args.push(tokens.slice(currentStart, j));
                            i = j;
                            break;
                        }
                    }
                    else if (scope === 0 && tokens[j].type == TokenType.COMMA) {
                        args.push(tokens.slice(currentStart, j));
                        currentStart = j + 1;
                    }
                }
                let parsedArgs: Token[][] = [];
                //now recursively process all arguments
                for (let k = 0; k < args.length; k++) {
                    parsedArgs[k] = [];
                    this.parse(args[k], parsedArgs[k]);
                }
                token.arguments = parsedArgs;
                destination.push(token);
            }
            else if (token.type == TokenType.NUMBER) {
                if (nextToken?.type == TokenType.FUNCTION ||
                    nextToken?.type == TokenType.NUMBER ||
                    nextToken?.type == TokenType.VARIABLE ||
                    nextToken?.type == TokenType.LPAREN) {
                    tokens.splice(i+1, 0, insertMultiplyToken(token.pos));
                }

                destination.push(token);
            }
            else if (token.type == TokenType.OPERATOR) {

                if (nextToken?.type == TokenType.OPERATOR) {
                    this.problems.push(problem(nextToken.pos, nextToken.name?.length ?? 0, Severity.WARNING, `Excess operator '${nextToken.name}', ignoring it`));
                    nextToken.type = TokenType.INVALID;
                }
                else if (!nextToken || nextToken.type == TokenType.RPAREN) {
                    this.problems.push(problem(token.pos, token.name?.length ?? 0, Severity.WARNING, `Missing right-side argument for operator '${token.name}', ignoring it`));
                    continue;
                }
                let top = operatorStack.at(-1);
                while (top && top.type != TokenType.LPAREN && (operators[top.name ?? ''].precedence > operators[token.name ?? ''].precedence || (operators[top.name ?? ''].precedence === operators[token.name ?? ''].precedence && operators[token.name ?? ''].assoc === 'left'))) {
                    operatorStack.pop();
                    //if (top.type == TokenType.OPERATOR) {
                    //    destination.push(convertOpToFn(top));
                    //} else {
                        destination.push(top);
                    //}
                    top = operatorStack.at(-1);
                }
                operatorStack.push(token);
            }
            else if (token.type == TokenType.LPAREN) {
                if (nextToken?.type == TokenType.OPERATOR && 1/*is unary, nextToken.arguments > 1*/) {
                    this.problems.push(problem(nextToken.pos, nextToken.name?.length ?? 0, Severity.ERROR, `Missing left-side argument for operator '${nextToken.name}', ignoring it`));
                    nextToken.type = TokenType.INVALID;
                }

                operatorStack.push(token);
            }
            else if (token.type == TokenType.RPAREN) {

                if (nextToken?.type == TokenType.NUMBER ||
                    nextToken?.type == TokenType.FUNCTION ||
                    nextToken?.type == TokenType.VARIABLE ||
                    nextToken?.type == TokenType.LPAREN) {
                    tokens.splice(i+1, 0, insertMultiplyToken(token.pos));
                }

                while (operatorStack.at(-1)?.type != TokenType.LPAREN) {
                    const lastOp = operatorStack.pop();
                    if (!lastOp) {
                        this.problems.push(problem(token.pos, 1, Severity.ERROR, `Mismatched parentheses: missing left parenthesis '('`));
                        return this;
                    }
                    //if (lastOp.type == TokenType.OPERATOR) {
                    //    destination.push(convertOpToFn(lastOp));
                    //} else {
                        destination.push(lastOp);
                    //}
                }
                const lparen = operatorStack.pop();
                if (!lparen || lparen.type != TokenType.LPAREN) {
                    this.problems.push(problem(0, 0, Severity.ERROR, `Mismatched parentheses: missing right parenthesis ')'`));
                }
                const top = operatorStack.at(-1);
                if (top && top.type == TokenType.FUNCTION) {
                    operatorStack.pop();
                    destination.push(top);
                }
            }
            else if (token.type == TokenType.COMMA) {
                //ignore
                //this.operatorStack.push(token);
            }
            else if (token.type == TokenType.EQUAL) {
                while (operatorStack.length) {
                    const op = operatorStack.pop();
                    if (!op || op.type == TokenType.LPAREN || op.type == TokenType.RPAREN) {
                        this.problems.push(problem(op?.pos ?? 0, op?.name?.length ?? 0, Severity.ERROR, `Mismatched parentheses`));
                        return this;
                    }
                    destination.push(op);
                }
                destination.push(token);
            }
        }
        while (operatorStack.length) {
            const op = operatorStack.pop();
            if (!op || op.type == TokenType.LPAREN || op.type == TokenType.RPAREN) {
                this.problems.push(problem(op?.pos ?? 0, op?.name?.length ?? 0, Severity.ERROR, `Mismatched parentheses`));
                return this;
            }
            //if (op.type == TokenType.OPERATOR) {
            //    destination.push(convertOpToFn(op));
            //} else {
                destination.push(op);
            //}
        }
        return this;
    }


        // for (let i = 0; i < expression.length; i++) {
//     const char = expression[i];
//     const nextChar = expression[i + 1];

//     if (char === ' ') {
//         continue;
//     }
//     else if (isLetter(char)) {
//         charStack += char;
//         if (isLetter(nextChar)) {
//             continue;
//         }
//         //now inspect charstack if it is a function or a variable
//         charStack.toLowerCase();
//         let fnFound = '';
//         for (const fn of functions) {
//             if (charStack.includes(fn)) {
//                 //found function
//                 //this.operatorStack.push(charStack);
//                 fnFound = fn;
//                 charStack = charStack.replace(fn, '');
//                 break;
//             }
//         }
//         for (const letter of charStack) {
//             this.outputQueue.push(letter);
//             //this.operatorStack.push('*');
//         }

//         if (fnFound) {
//             this.operatorStack.push(fnFound);
//         }
//         charStack = '';
//     }
//     else if (isNumber(char)) {
//         charStack += char;
//         if (isNumber(nextChar)) {
//             continue;
//         }
//         if (isLParen(nextChar) || isLetter(nextChar)) {
//             this.operatorStack.push('*');
//         }
//         //push number to output queue
//         this.outputQueue.push(charStack);
//         charStack = '';
//     }
//     else if (isOperator(char)) {
//         let ch = char;
//         if (nextChar == char) {
//             ch += nextChar;
//             i++;
//         }
//         let top = this.operatorStack.length ? this.operatorStack[this.operatorStack.length - 1] : '';
//         while (top && !isLParen(top) && (getPrecedence(top) > getPrecedence(ch) || (getPrecedence(top) === getPrecedence(ch) && getAssociativity(ch) === 'left'))) {
//             this.operatorStack.pop();
//             this.outputQueue.push(top);
//             top = this.operatorStack.length ? this.operatorStack[this.operatorStack.length - 1] : '';
//         }
//         this.operatorStack.push(ch);
//     }
//     else if (isLParen(char)) {
//         this.operatorStack.push(char);
//     }
//     else if (isRParen(char)) {

//         while (!isLParen(this.operatorStack[this.operatorStack.length - 1])) {
//             const lastOp = this.operatorStack.pop();
//             if (!lastOp) {
//                 this.errors.push({ name: '', description: 'Mismatched parentheses: missing left parenthesis', character: i, length: 1 });
//                 return;
//             }
//             this.outputQueue.push(lastOp);
//         }
//         const lparen = this.operatorStack.pop();
//         if (!lparen || !isLParen(lparen)) {
//             this.errors.push({ name: '', description: 'Mismatched parentheses: missing left parenthesis', character: i, length: 1 });
//             return;
//         }
//         const top = this.operatorStack[this.operatorStack.length - 1];
//         if (top) {
//             for (const fn of functions) {
//                 if (top.includes(fn)) {
//                     //found function
//                     this.operatorStack.pop();
//                     this.outputQueue.push(top);
//                     break;
//                 }
//             }
//         }
//         if (nextChar && !isOperator(nextChar)) {
//             this.operatorStack.push('*');
//         }
//     }
// }
// while (this.operatorStack.length) {
//     const op = this.operatorStack.pop();
//     if (!op || isLParen(op) || isRParen(op)) {
//         //throw error
//         return;
//     }
//     this.outputQueue.push(op);
// }
// return this.outputQueue;



// function getPrecedence(op: string) {
//     switch (op) {
//         case '**':
//         case '^':
//             return 8;
//         case '*':
//         case '/':
//         case '÷':
//         case '%':
//             return 7;
//         case '+':
//         case '-':
//             return 6;
//         case '<<':
//         case '>>':
//             return 5;
//         case ',':
//             return 1;
//         default:
//             return 0;
//     }
// }

// function getAssociativity(op: string) {
//     switch (op) {
//         case '**':
//         case '^':
//             return 'right';
//         default:
//             return 'left';
//     }
// }

// function isFunction(str: string) {
//     return /^(sin|cos|tan|min|max|mod|sqrt|root|abs|fac|round|int)$/.test(str);
// }
// declare global {
//     interface Array<T> {
//         top(): T;
//     }
// }

// if (!Array.prototype.top) {
//     Array.prototype.top = function <T>(): T {
//         return this.at(-1);//this.filter(e => e !== elem);
//     }
// }



// let fnResult = 0;
// switch (token.name) {
//     case 'sin':
//         fnResult = Math.sin(args[0]);
//         break;
//     case 'cos':
//         fnResult = Math.cos(args[0]);
//         break;
//     case 'tan':
//     case 'tg':
//         fnResult = Math.tan(args[0]);
//         break;
//     case 'sqrt':
//         fnResult = Math.sqrt(args[0]);
//         break;
//     case 'root':
//         fnResult = Math.pow(args[0], 1 / args[1]);
//         break;
//     case 'pow':
//     case 'power':
//         fnResult = Math.pow(args[0], args[1]);
//         break;
//     case 'abs':
//         fnResult = Math.abs(args[0]);
//         break;
//     case 'min':
//         fnResult = Math.min(args[0], args[1]);
//         break;
//     case 'max':
//         fnResult = Math.max(args[0], args[1]);
//         break;
//     case 'mod':
//         fnResult = ((args[0] % args[1]) + args[1]) % args[1];
//         break;
//     case 'fac':
//         fnResult = args[0] * gamma(args[0]);
//         break;
//     case 'round':
//         fnResult = Math.round(args[0]);
//         break;
//     case 'trunc':
//         fnResult = Math.trunc(args[0]);
//         break;
//     case 'ceil':
//         fnResult = Math.ceil(args[0]);
//         break;
//     case 'floor':
//         fnResult = Math.floor(args[0]);
//         break;
//     case 'sign':
//         fnResult = Math.sign(args[0]);
//         break;
//     case 'add':
//         fnResult = args[0] + args[1];
//         break;
//     case 'sub':
//         fnResult = args[0] - args[1];
//         break;
//     case 'mul':
//         fnResult = args[0] * args[1];
//         break;
//     case 'div':
//         fnResult = args[0] / args[1];
//         break;
//     case 'shl':
//         fnResult = args[0] << args[1];
//         break;
//     case 'shr':
//         fnResult = args[0] >> args[1];
//         break;
//     case 'not':
//         fnResult = ~args[0];
//         break;
//     case 'and':
//         fnResult = args[0] & args[1];
//         break;
//     case 'or':
//         fnResult = args[0] | args[1];
//         break;
//     case 'xor':
//         fnResult = args[0] ^ args[1];
//         break;
//     case 'pi':
//         fnResult = Math.PI;
//         break;
//     case 'ln':
//         fnResult = Math.log(args[0]);
//         break;
//     case 'log':
//         fnResult = Math.log10(args[0]);
//         break;
//     case 'exp':
//         fnResult = Math.exp(args[0]);
//         break;
//     //case 'sum':
//     //break;
//     case 'dr':
//         fnResult = args[0] - variables.prevX;
//         break;
//     default:
//         this.problems.push(problem(0, 0, Severity.FATAL_ERROR, `Unknown function '${token.value}'`));
//         return this;

// }

// case TokenType.OPERATOR:
                //     const arg1 = tmpStack.pop() as number;
                //     const arg0 = tmpStack.pop() as number;
                //     let result = 0;
                //     switch (token.value) {
                //         case '+':
                //             result = arg0 + arg1;
                //             break;
                //         case '-':
                //             result = arg0 - arg1;
                //             break;
                //         case '*':
                //         case '·':
                //             result = arg0 * arg1;
                //             break;
                //         case '/':
                //         case '÷':
                //             result = arg0 / arg1;
                //             break;
                //         case '^':
                //         case '**':
                //             result = Math.pow(arg0, arg1);
                //             break;
                //         case '%':
                //             result = arg0 % arg1;
                //             break;
                //     }
                //     tmpStack.push(result);
                //     break;


// const functions: {[key: string]: number} = {
//     'sin': 1,
//     'cos': 1,
//     'tan': 1,
//     'tg': 1,
//     'sqrt': 1,
//     'root': 2,
//     'power': 2,
//     'pow': 2,
//     'abs': 1,
//     'max': 2,
//     'min': 2,
//     'mod': 2,
//     'fac': 1,
//     'round': 1,
//     'trunc': 1,
//     'ceil': 1,
//     'floor': 1,
//     'sign': 1,
//     'add': 2,
//     'sub': 2,
//     'mul': 2,
//     'div': 2,
//     'shl': 2,
//     'shr': 2,
//     'not': 1,
//     'and': 2,
//     'or': 2,
//     'xor': 2,
//     'pi': 0,
//     'ln': 1,
//     'log': 1,
//     'exp': 1,
//     'sum': 4,
//     'der': 1
// };




//now inspect charstack if it is a function or a variable
                // charStack.toLowerCase();
                // let fnFound = '';
                // for (const fn in functions) {
                //     if (charStack.includes(fn)) {
                //         //found function
                //         //this.operatorStack.push(charStack);
                //         fnFound = fn;
                //         charStack = charStack.replace(fn, '');
                //         break;
                //     }
                // }
                // for (const letter of charStack) {
                //     this.tokenStack.push({type: TokenType.VARIABLE, value: letter, precedence: 0, associativity: 'none', pos: i});
                // }

                // if (fnFound) {
                //     this.tokenStack.push({ type: TokenType.FUNCTION, value: fnFound, precedence: 10, associativity: 'none', pos: i });
                // }


                // if (isLParen(nextChar)) {
                //     //function

                //     let args = 0;
                //     let found = -1;
                //     for (let j = i + 1; j < expression.length; j++){
                //         if (isRParen(expression[j])) {
                //             found = j;
                //         }
                //     }
                //     if (i + 2 == found) {
                //         args = 0;
                //     }
                //     else {
                //         args = expression.substring(i + 2, found == -1 ? undefined : found - 1).split(',').length;
                //     }
                //     //console.log('Args:' + args);
                //     this.tokenStack.push({ type: TokenType.FUNCTION, value: charStack, precedence: 10, associativity: 'none', pos, arguments: args });

                // }
                // else {
                //     //variable(s)
                //     for (const letter of charStack) {
                //         this.tokenStack.push({type: TokenType.VARIABLE, name: letter, pos});
                //     }
                // }
                // charStack = '';



                                    // for (let i = 0; i < argc; i++){
                    //     const arg = tmpStack.pop();
                    //     if (arg === undefined) {
                    //         this.problems.push(problem(i, 0, Severity.FATAL_ERROR, `Internal Error: Not enough arguments for function '${token.value}'`));
                    //         return this;
                    //     }
                    //     args.push(arg);
                    // }
                    // args.reverse();
                    //tmpStack.push(functions[token.name].fn(args));



                    // function calculate(lines: LineParams) {
//     for (const lineKey in lines) {
//         const line = lines[lineKey];
//         if (!line || !line.on) continue;

//         //let prevY = 0;
//         line.points = [];
//         for (let i = -10; i < 20; i += 0.0005) {
//             const y = line.fn(i);

//             //const delta = Math.abs(prevY - y);
//             // if (delta > 1) {
//             //     for (let j = i - 0.0005; j < i; j += 0.0005 / delta) {
//             //         line.points.push({ x: i, y: j, connect: true });
//             //     }
//             // }
//             // let y = 0;
//             // for (let n = 1; n < 1000; n++){
//             //     y += 1 / (2 * n - 1) * Math.sin(2 * Math.PI * i * (2 * n - 1));
//             // }
//             //prevY = y;
//             line.points.push({ x: i, y, connect: true, selected: false });
//         }
//         self.postMessage(line);
//     }
// }